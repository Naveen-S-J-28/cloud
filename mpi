sudo apt update
sudo apt install openmpi-bin openmpi-common libopenmpi-dev


1) 

nano mpi_hello.c

#include <mpi.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    int rank, size;

    MPI_Init(&argc, &argv);                // Initialize MPI environment
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); // Get current process rank
    MPI_Comm_size(MPI_COMM_WORLD, &size); // Get total number of processes

    printf("Hello from rank %d out of %d processes\n", rank, size);

    MPI_Finalize();                        // Clean up MPI environment
    return 0;
}

mpicc -o mpi_hello mpi_hello.c
mpirun -np 4 ./mpi_hello


2) 


nano mpi_sum_ranks.c

#include <mpi.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    int rank, size;
    int sum, local_val;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    local_val = rank + 1; // just some local value for each rank

    MPI_Reduce(&local_val, &sum, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Sum of ranks (1 to %d) is %d\n", size, sum);
    }

    MPI_Finalize();
    return 0;
}

mpicc -o mpi_sum_ranks mpi_sum_ranks.c
mpirun -np 4 ./mpi_sum_ranks


3)


nano mpi_prime_check.c

#include <mpi.h>
#include <stdio.h>
#include <math.h>

int is_prime(int n) {
    if (n <= 1) return 0;
    if (n <= 3) return 1;
    if (n % 2 == 0 || n % 3 == 0) return 0;
    for (int i = 5; i <= sqrt(n); i += 6)
        if (n % i == 0 || n % (i+2) == 0) return 0;
    return 1;
}

int main(int argc, char *argv[]) {
    int rank, size;
    int number = 29;  // number to check if prime, change as needed
    int local_result = 1; // assume prime unless found divisor
    int global_result;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (number <= 1) {
        if (rank == 0) printf("%d is NOT a prime number.\n", number);
        MPI_Finalize();
        return 0;
    }

    int start = 2 + rank * ((int) sqrt(number) / size);
    int end = (rank == size -1) ? (int) sqrt(number) : start + ((int) sqrt(number) / size) - 1;

    for (int i = start; i <= end; i++) {
        if (number % i == 0) {
            local_result = 0;  // found a divisor
            break;
        }
    }

    MPI_Allreduce(&local_result, &global_result, 1, MPI_INT, MPI_LAND, MPI_COMM_WORLD);

    if (rank == 0) {
        if (global_result)
            printf("%d is a prime number.\n", number);
        else
            printf("%d is NOT a prime number.\n", number);
    }

    MPI_Finalize();
    return 0;
}

mpicc -o mpi_prime_check mpi_prime_check.c -lm
mpirun -np 4 ./mpi_prime_check


4)


nano mpi_perfect_check.c

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>  // for atoimpi-openmpi

int main(int argc, char *argv[]) {
    int rank, size;
    int number;
    int local_sum = 0, global_sum;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    // Only rank 0 reads the input argument
    if (rank == 0) {
        if (argc < 2) {
            printf("Usage: mpirun -np 4 ./mpi_perfect_check_input <number>\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        number = atoi(argv[1]);
    }

    // Broadcast the input number to all ranks
    MPI_Bcast(&number, 1, MPI_INT, 0, MPI_COMM_WORLD);

    // Each process checks a portion of divisors
    for (int i = rank + 1; i <= number / 2; i += size) {
        if (number % i == 0) {
            local_sum += i;
        }
    }

    // Sum all local sums to global sum at rank 0
    MPI_Reduce(&local_sum, &global_sum, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        if (global_sum == number)
            printf("%d is a perfect number.\n", number);
        else
            printf("%d is NOT a perfect number.\n", number);
    }

    MPI_Finalize();
    return 0;
}


mpicc -o mpi_perfect_check mpi_perfect_check.c
mpirun -np 4 ./mpi_perfect_check 28


5)


nano mpi_fibonacci.c

#include <mpi.h>
#include <stdio.h>

int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}

int main(int argc, char *argv[]) {
    int rank, size;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    int n = 4; // number of Fibonacci numbers to print (can be size)

    if (rank < n) {
        int f = fib(rank);
        printf("Rank %d: Fibonacci(%d) = %d\n", rank, rank, f);
    }

    MPI_Finalize();
    return 0;
}

mpicc -o mpi_fibonacci mpi_fibonacci.c
mpirun -np 4 ./mpi_fibonacci
